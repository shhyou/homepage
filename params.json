{"name":"Shu-Hung, You","tagline":"","body":"# Shu-Hung You\r\nI was a student from\r\n[Dept. of Computer Science and Information Engineering](http://www.csie.ntu.edu.tw),\r\n[National Taiwan University](http://www.ntu.edu..tw).\r\nMy main interests include the theory, design, and implementation\r\nof programming languages. I hope to apply methodologies from\r\nprogramming languages to create correct and efficient programs.\r\n\r\n## Publication\r\n- Bruno C. d. S. Oliveira, Shin-Cheng Mu and Shu-Hung You.\r\n    Modular Refiable Matching: a list-of-functor approach to two-level types.\r\n    In *Proceedings of the 8th ACM SIGPLAN Symposium on Haskell*\r\n    (Haskell'15).\r\n\r\n    [[paper]](http://dl.acm.org/citation.cfm?id=2804315)\r\n\r\n    This paper presents Modular Reifiable Matching (MRM):\r\n    a new approach to two level types using a\r\n    _fixpoint of list-of-functors_ representation.\r\n    MRM allows the modular definition of datatypes and\r\n    functions by pattern matching, using a style similar to\r\n    the widely popular Datatypes a la Carte (DTC) approach.\r\n\r\n    However, unlike DTC, MRM uses a fixpoint of list-of-functors\r\n    approach to two-level types. This approach has advantages\r\n    that help with various aspects of extensibility, modularity\r\n    and reuse. Firstly, modular pattern matching definitions\r\n    are collected using a list of matches that is fully reifiable.\r\n    This allows for extensible pattern matching definitions\r\n    to be easily reused/inherited, and particular matches\r\n    to be overridden. Such flexibility is used, among other\r\n    things, to implement _extensible generic traversals_.\r\n    Secondly, the subtyping relation between lists of\r\n    functors is quite simple, does not require backtracking,\r\n    and is easy to model in languages like Haskell.\r\n    MRM is implemented as a Haskell library, and its use and\r\n    applicability are illustrated through various examples\r\n    in the paper.\r\n\r\n## Education\r\n- **B.S.** in [Computer Science and Information Engineering](http://www.csie.ntu.edu.tw/), [National Taiwan University](http://www.ntu.edu.tw/), Sep. 2011--Jun. 2015\r\n\r\n## Projects\r\n### CFALet\r\n[[project]](https://github.com/suhorng/cfalet/tree/master/src)\r\n\r\nCFALet includes a static analyzer derived along the\r\nAbstracting Abstract Machines methodology and a simple\r\ndemo tool. CFALet is a trial to loosen the value restriction\r\nin Standard ML type systems by program analysis.\r\n\r\n### MiniFn\r\n[[project]](https://github.com/suhorng/ss/tree/master/minifn) [[slide@funth#11]](http://suhorng.github.io/ss/ft11/ccs.html) [[pdf]](http://suhorng.github.io/ss/ft11/Poor%20Man%27s%20Undergraduate Compilers.pdf) [[code]](https://github.com/suhorng/ss/tree/master/ft11)\r\n\r\nMiniFn is a bare-metal compiler of a minimal functional language\r\nwritten in Scheme.\r\nIt compiles directly to x86 assembly.\r\n\r\n- Syntax:\r\n\r\n    ```\r\n    e ::= c                       ; constants\r\n        | x                       ; variable\r\n        | (lambda (x1 [x2 ...]) e); lambda abstraction\r\n        | (ifz con th el)         ; testing whether con is zero\r\n        | (prim-binop e1 e2)      ; primitive binary operator\r\n        | (fix e)                 ; built-in fixed-point combinator\r\n        | (e1 e2 [e3 ...])        ; function application\r\n\r\n    t ::= Int\r\n        | Unit\r\n        | (* t1 t2 [t3 ...])      ; n-tuple, n = 2, 3, 4, ...\r\n        | t1 -> t2\r\n    ```\r\n\r\n- Language:\r\n\r\n    * Constants include:\r\n      * integers, `..., -2, -1, 0, 1, 2, ... :: Int`\r\n      * unit, `() :: Unit`\r\n    * Primitive binary operators:\r\n      * integer operations: addition `+`, multiplication `*`, both having type `(Int, Int) -> Int`\r\n    * Statically typed without polymorphism\r\n    * Call-by-value and right-to-left evaluation\r\n\r\n### λIntr\r\n[[project]](https://github.com/suhorng/llintr) [[slide@funth#5]](http://suhorng.github.io/llintr/lvm.html) [[code]](https://github.com/suhorng/llintr/tree/master/ft5-present/code)\r\n\r\nλIntr is a call-by-value λ-calculus interpreter, byte-code\r\ncompiler written in Haskell and a derived virtual machine written in C++.\r\nThe source language uses Hindley-Milner type system.\r\n\r\n### C--\r\n[[project]](https://github.com/suhorng/compiler13hw/) [[slide@funth#11]](http://suhorng.github.io/ss/ft11/ccs.html) [[pdf]](http://suhorng.github.io/ss/ft11/Poor%20Man%27s%20Undergraduate Compilers.pdf)\r\n\r\nA compiler for a subset of C language written in Haskell.\r\nThe source language is transformed to a low-level intermediate\r\nform inspired by LLVM, from which the MIPS assembly is generated.\r\n\r\n### RSA-GCD\r\n\r\nRSA-GCD is a project for factoring RSA keys by calculating the\r\ncommon divisors of a large collection of RSA keys. This vulnerability\r\nwas discovered by [Heninger et al](https://factorable.net/) in 2012.\r\nOur algorithm is slightly different and simplier from theirs.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}